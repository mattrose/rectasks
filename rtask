#!/usr/bin/env bash
# vim: set ts=4 sw=4 et:

if [[ -e $HOME/.local/lib/rtask-util ]] ; then
    source $HOME/.local/lib/rtask-util
else
    echo "Cannot find rtask-util, make sure it is in $HOME/.local/lib/rtask-util"
    echo "Have you run the `install` script"
fi

usage() {
    cat <<'EOF'

    RTASK is a simple recursive task manager that helps you organize
    everything that is thrown at you on a daily basis.  It's designed 
    to be:
    1. Easy to use.  lets you add and edit tasks easily from the command
       line and stays out of your way.
    2. Simple.  It's just files on disk, so it can theoretically contain
       anything you want, and information can be easily drawn from it
    3. Allows you to set up an infinite (theoretically) amount of sub tasks
    4. Allows you to add comments to tasks to add context.

    USAGE: rtask <action> <taskid> <text>
    if not given any arguments, rtask prints out a list of tasks
    
    Available Actions
    
    * add: rtask add <taskid> <text>.
      * if taskid is not specified it opens a new task
      * If taskid is specified, it opens a sub-task  
      * If text is not specified, it opens an editor
    * list: rtask list <taskid>
      * if taskid is specified, it prints out all the 
        detailsx for that task
    * complete: rtask complete taskid
      * marks a task as complete and removes it from 
        the list view
    * edit: rtask edit taskid 
      * opens $EDITOR for that task
    * comment: rtask comment taskid
      * adds a comment to a task
    *  

EOF
   
}

tasksdir=$(gettasksdir)
[[ -d $tasksdir ]] || mkdir -p $tasksdir 
pushd $tasksdir > /dev/null 

[[ -z $1 ]] && action=priority || action=$1
shift 1
### if the next argument matches a taskid...
if echo $1 | grep -q -E "^\d+(\.\d+)*$" ; then
       taskid=$1
       shift 1
fi
text="$*"

main() {
    case $action in 
        edit)
            edit $taskid
            ;;
        complete)
            finish $taskid
            ;;
        move)
            move $taskid $text
            ;;
        add)
            add "$text"
            ;;
        details)
            details $taskid
            ;;
        list)
            if [[ -v taskid ]] ; then 
                details $taskid 
            else
                list 
            fi
            ;;
        priority)
            setpriority $taskid $text 
            ;;
        comment)
            comment "$text"
            ;;
        setpriority)
            setpriority $taskid $text
            ;;
        *)
            usage
            exit 1
            ;;
    esac    
}

finish() {
    touch $(taskpath $1)/complete
}

move() {
    mv $(taskpath $1) $(newtaskpath $2)
    echo $(taskpath $1)
    echo $(newtaskpath $2) 
}
details() {
    path=$(taskpath $taskid)
    if [[ -e $path/complete ]] ; then echo -n "DONE: " ; fi
    if [[ -e $path/task ]] ; then cat $path/task ; fi
    if [[ -d $path/comments ]] ; then cat $path/comments/* ; fi
    if [[ -e $path/priority ]] ; then echo -n "P " ; cat $path/priority ; fi
}

list() {
    tasklist=$(for f in $(find . -name task) ; do td=$(dirname $f) ; if [[ -e $td/priority ]] ; then p=$(cat $td/priority) ; else p=0 ; fi ; echo "$p $f" ; done | sort -k1,1nr -k2,2n | cut -f 2- -d ' ')
    # tasklist=$(find . -name task | sort -n)
    for f in $tasklist ; do
        taskdir="$(dirname $f)"
        if [[ -e $taskdir/complete ]] ; then
            continue
        fi
        taskfile=$(taskid $f)
        comments=$(getcommentcount $f)
        echo -n "$taskfile: "
        if [[ $comments -ne 0 ]] ; then
            echo -n "($comments) "
        fi
	    cat $f
    done
}

add() {
    path=$(newtaskpath $taskid)
    mkdir -p $path
    [[ -z $text ]] && ${EDITOR:=vim} $path/task || echo "$text" > ${path}/task
}

comment() {
    path=$(newcommentpath $taskid)
    mkdir -p $(dirname $path)
    [[ -z $* ]] && ${EDITOR:=vim} $path || echo $* > $path
}

edit() {
    ${EDITOR:=vim} $(taskpath $1)/task
}

setpriority() {
    path=$(taskpath $1)/priority
    echo $2 > $path
}

main
